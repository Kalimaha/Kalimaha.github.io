<script type='text/x-handlebars-template' id='use_docker_to_run_flask_based_rest_services'>
  <p>
    Many articles of this kind exist, but most of these tutorials start from
    the easiest Flask example possible:
  </p>
  <pre>
    <code class="example python">
      from flask import Flask

      app = Flask(__name__)

      @app.route("/")
      def hello():
          return "Hello World!"

      if __name__ == "__main__":
          app.run()
    </code>
  </pre>
  <br>
  <p>
    Although these examples are very useful to understand the Docker setup,
    the objective of this post is to present a situation that is closer
    (<i>just a little bit!</i>) to the real life. The final Docker image will contain
    the REST services, and it will be possible to install the whole
    application on any machine supporting Docker. In addition to having a fully
    functional web application that can be quickly deployed, this approach
    also allows the versioning, the configurability, the portability and the
    share of the deploy objects, a.k.a. the Docker images.
  </p>
  <h1>
    Architecture
  </h1>
  <p>
    The architecture is composed by two back-end modules: the main REST
    service and an additional service implemented as a Flask blueprint.
    A <a href="http://flask.pocoo.org/docs/0.10/blueprints/" target="_blank"><u>Flask blueprint</u></a>
    “<i>works similarly to a Flask application object, but it is not actually an
    application. Rather it is a blueprint of how to construct or extend an
    application</i>“. The use of such objects allows the implementation of a modular
    back-end.
  </p>
  <br>
    <img class="img-responsive center-block" src="../src/images/simple_flask_01.png">
  <br>
  <p>
    Back-end projects have been organized in a <code>core</code> and a
    <code>rest</code> package to isolate even more the responsibilities of
    each element. The structure of such projects is shown below:
  </p>
  <pre>
    <code class="example">
      simple_flask/
      ├── requirements.txt
      ├── setup.py
      ├── simple_flask
      │   ├── core
      │   │   └── core.py
      │   └── rest
      │       └── rest.py
      └── simple_flask_test
          ├── core
          │   └── core_test.py
          └── rest
              └── rest_test.py
    </code>
  </pre>
  <br>
  <p>
    Enters Docker. The final goal is to encapsulate the whole application
    inside Docker. As shown in the next figure this process will be seamless
    for the final user, that will keep interacting with the application
    with no extra settings required.
  </p>
  <br>
    <img class="img-responsive center-block" src="../src/images/simple_flask_02.png">
  <br>
  <h1>
    Source Code
  </h1>
  <p>
    The source code of all the projects used in this tutorial is available on
    GitHub: feel free to download, fork and/or star it!
  </p>
  <table class="table table-striped table-bordered table-condensed table-hover">
    <thead>
      <tr>
        <th>Project</th>
        <th>URL</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Simple Flask</td>
        <td>
          <a href="https://github.com/Kalimaha/simple_flask" target="_blank">
            https://github.com/Kalimaha/simple_flask
          </a>
        </td>
      </tr>
      <tr>
        <td>Simple Flask Blueprint</td>
        <td>
          <a href="https://github.com/Kalimaha/simple_flask_blueprint" target="_blank">
            https://github.com/Kalimaha/simple_flask_blueprint
          </a>
        </td>
      </tr>
      <tr>
        <td>Simple Flask Dockerizer</td>
        <td>
          <a href="https://github.com/Kalimaha/simple_flask_dockerizer" target="_blank">
            https://github.com/Kalimaha/simple_flask_dockerizer
          </a>
        </td>
      </tr>
    </tbody>
  </table>
  <h1>
    Flask Blueprint
  </h1>
  <p>
    As mentioned before blueprints are objects used to create a modular
    application. This simple component follows the structure previously
    described and contains a core library and, of course, a blueprint. The
    only function of the core is used to greet the user:
  </p>
  <pre>
    <code class="example python">
      def say_hallo(name=None):
        return 'Hallo ' + str(name) + '!' if name is not None else 'Hallo!'
    </code>
  </pre>
  <br>
  <p>
    The blueprint itself is very simple as well: it exposes two routes to
    greet the user, one generic, and one customizable with the user name.
    The resulting service takes advantage of the core library to do so:
  </p>
  <pre>
    <code class="example python">
      from flask import Blueprint
      from simple_flask_blueprint.core.blueprint_core import say_hallo

      bp = Blueprint('simple_flask_blueprint', __name__)

      @bp.route('/')
      def say_hallo_service():
          return say_hallo()

      @bp.route('/&lt;name&gt;/')
      def say_hallo_to_guest_service(name):
          return say_hallo(name)
    </code>
  </pre>
  <br>
  <p>
    As shown by the code the development of the service is very similar to
    the standard Flask, with the only exception of the Blueprint object
    declared at line 5.
  </p>
  <h1>
    Flask REST Service
  </h2>

  <script>
    hljs.highlightBlock($('.example').get(0))
    hljs.highlightBlock($('.example').get(1))
    hljs.highlightBlock($('.example').get(2))
    hljs.highlightBlock($('.example').get(3))
  </script>
</script>
